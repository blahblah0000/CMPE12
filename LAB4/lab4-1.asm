// READ ME
// Lynne Diep
// lytdiep@ucsc.edu
// TA: Chandaras
// Due Date: November 7, 2016
// Section: 1I on Tuesdays/Thursdays @ 2PM
// row major


.ORIG x3000

GREET .STRINGZ "Hello, welcome to my Caesar Cipher program"
ASK .STRINGZ "Do you want to (E)ncrypt or D(ecrypt) or e(X)it?"
CIPHER .STRINGZ "What is the cipher (1-25)?"
SENTENCE .STRINGZ "What is the string? (up to 200 characters)?"
RESULT .STRINGZ "Here is your string and the decrypted result"

	LEA R0, GREET				; "HELLO, WELCOME..."
	PUTS
	LD R0 NEWLINE
	OUT

INTRO
	LEA R0, ASK				; "DO YOU WANT TO ENCRYPT OR DECRYPT OR EXIT"
	PUTS
	LD R0 NEWLINE
	OUT					; DISPLAY INPUT
	GETC					; TAKE IN INPUT
	OUT					; DISPLAY INPUT
	LD R1 NEGX
	ADD R1 R0 R1				; R1 = R0 + R1
	BRz END 				; BRANCH IF ZERO TO END
	LD R1 LETTERD
	ADD R1 R1 R0				; R1  = R1 + R0
	BRz DECRYPT_FLAG 			; BRANCH IF ZERO TO DECRYPT_FLAG
	LD R1 LETTERE
	ADD R1 R1 R0				; R1 = R1 + R0
	BRz ENCRYPT_FLAG 			; BRANCH IF ZERO TO ENCRYPT_FLAG

START
	GETC					; USER INPUT
	ADD R1 R0 #-10				; IF USER PRESSES "ENTER" THEN GO TO BRANCH 'ENTER'
	BRz ENTER 				; BRANCH IF ZERO TO ENTER
	LEA R2 INTEGER				; LOAD FIRST ADDRESS OF INTEGER	
	ADD R2 R2 R3				; SHIFT ADDRESS BY R3
	LD R1 NEG48				; LOAD -48 INTO R1
	OUT					; OUTPUT VALUE
	ADD R0 R0 R1				; CONVERT INPUT FROM ASCII TO TRUE DECIMAL
	STR R0 R2 #0				; STORE USER INPUT INTO R0
	ADD R3 R3 #1				; ADD ONE TO COUNTER
	AND R1 R1 #0				; CLEAR R1
	BR START

ENTER
	ADD R4 R3 #-2				; IF LOOPED TWICE, GO TO TENS MULTI
	BRz MULTI10 				; BRANCH TO MULTI10 IF ZERO
	ADD R4 R3 #-1				; IF LOOPED ONCE, GO TO ONES MULTI
	BRz MULTI1 				; BRANCH TO MULTI1 IF ZERO

MULTI10
	LEA R2 INTEGER				; LOAD FIRST ADDRESS OF INTEGER
	LDR R4 R2 #0 				; ADD SIGN-EXTENED 6 BIT OFFSET TO R4 FROM R2
	NOT R4 R4 				; INVERT R4
	ADD R4 R4 #1				; SHIFT R4 BY 1

LOOP10
	ADD R6 R6 #1				; ADD ONE TO COUNTER
	ADD R5 R5 #10				; BEGIN MULTIPLICATION OF 10
	ADD R4 R4 R6				; IF NEGATIVE KEEP LOOPING, ELSE STOP
	BRn LOOP10 				; BRANCH IF NEGATIVE TO LOOP10
	STR R5 R2 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R5 FROM R2
	AND R5 R5 #0				; CLEAR R5
	BR SUM

MULTI1
	LEA R2 INTEGER				; LOAD FIRST ADDRESS OF INTEGER
	LDR R4 R2 #1 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R4
	NOT R4 R4				; INVERT R4
	ADD R4 R4 #1				; SHIFT R4 BY 1

LOOP1
	ADD R6 R6 #1				; ADD ONE TO COUNTER
	ADD R5 R5 #1 				; BEGIN MULTIPLICATION OF 1
	ADD R4 R4 R6				; IF NEGATIVE KEEP LOOPING, ELSE STOP
	BRn LOOP1 				; BRANCH IF NEGATIVE TO LOOP1
	STR R5 R2 #1 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R5 FROM R2
	AND R5 R5 #0				; CLEAR R5
	BR SUM

INTEGER .BLKW 2

SUM
	AND R3 R3 #0				; CLEAR R3
	LEA R2 INTEGER				; LOAD FIRST ADDRESS OF INTEGER TO R2
	LDR R3 R2 #0				; LOAD VALUE IN ADDRESS INTO R3
	LDR R4 R2 #1				; LOAD VALUE IN SECOND ADDRESS INTO R4
	ADD R4 R4 R3				; R4+R3=R4
	LEA R2 TOTAL_INTEGER
	STR R4 R2 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R4 FROM R2
	LD R0 NEWLINE
	OUT 					; DISPLAY INPUT
	LEA R0 SENTENCE				; "WHAT IS THE STRING"
	PUTS
	LD R0 NEWLINE
	OUT 					; DISPLAY INPUT
	AND R4 R4 #0				; CLEAR R4
	AND R2 R2 #0				; CLEAR R2
	BR STRING 				; BRANCH TO STRING

TOTAL_INTEGER .BLKW 1

FLAGD .BLKW 1
FLAGE .BLKW 1

DECRYPT_FLAG
	LD R0 NEWLINE
	OUT 					; DISPLAY INPUT
	LEA R0 CIPHER				; "WHAT IS THE CIPHER (1-25)?"
	PUTS 
	LD R0 NEWLINE
	OUT 					; DISPLAY INPUT
	LEA R1 FLAGD				; LOAD VALUE OF FLAGD INTO R1
	AND R2 R2 #0				; CLEAR R2
	ADD R2 R2 #1				; SHIFT R2 BY 1
	STR R2 R1 #0				; STORE VALUE OF R1 TO R2
	AND R3 R3 #0				; CLEAR R3
	BR START				; BRANCH TO START

NEGX .FILL #-120
NEWLINE .FILL #10
LETTERD .FILL #-100
LETTERE .FILL #-101
LIMIT .FILL #-200
NEG48 .FILL #-48

ENCRYPT_FLAG
	LD R0 NEWLINE1
	OUT
	LEA R0 CIPHER				; "WHAT IS THE CIPHER?"
	PUTS
	LD R0 NEWLINE1
	OUT					; DISPLAY INPUT
	LEA R1 FLAGE	
	AND R2 R2 #0				; CLEAR R2
	ADD R2 R2 #1				; SHIFT R2 BY 1
	STR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R1
	AND R3 R3 #0				; CLEAR R3
	BR START

FINISHED
	LD R0 NEWLINE1
	OUT
	AND R1 R1 #0				; CLEAR R1
	LEA R0 FLAGE				; LOAD ADDRESS OF FLAGE TO R0
	STR R1 R0 #0				; STORES R0 TO R1
	LEA R0 FLAGD				; LOAD ADDRESS OF FLAGD TO R0
	STR R1 R0 #0				; STORES R0 TO R1
	LEA R0 TOTAL_INTEGER			; LOAD ADDRESS OF TOTAL_INTEGER TO R0
	STR R1 R0 #0				; STORES R0 TO R1
	LEA R0 INTEGER				; LOAD ADDRESS OF INTEGER TO R0
	STR R1 R0 #0				; STORES R0 TO R1
	STR R1 R0 #1				; STORES R0+1 TO R1
	LEA R0 COUNTER				; LOAD ADDRESS OF COUNTER TO R0
	STR R1 R0 #0				; STORES R0 TO R1
	BR INTRO
	END
HALT

STRING
	GETC					; GETS USERS INPUT
	ADD R5 R0 #-10				; IF USER PRESSES 'ENTER' GO TO STRING2
	BRz STRING2 				; BRANCH TO STRING2 IF ZERO
	OUT					; DISPLAYS INPUT
	LEA R1 STRINGSTR1			; LOADS ADDRESS OF STRINGSTR1 TO R1
	ADD R1 R1 R2 				; R1 = R1 + R2
	STR R0 R1 #0				; STORES R1 TO R0
	LD R3 LIMIT
	ADD R2 R2 #1				; INCREASE R2 COUNTER BY 1
	ADD R4 R3 R2 				; R4 = R3 + R2
	BRz STRING2 				; BRANCH TO STRING2 IF ZERO
	BR STRING 				; BRANCH TO STRING

COUNTER .BLKW 1

STRING2
	LD R0 NEWLINE1
	OUT
	LEA R0 RESULT				; "HERE IS YOUR STRING...."
	PUTS
	LEA R3 COUNTER				; LOADS VALUE OF COUNTER TO R3
	NOT R2 R2 				; INVERT R2
	ADD R2 R2 #1				; SHIFT R2 BY 1
	STR R2 R3 #0				; STORES R3 INTO R2
	AND R3 R3 #0				; CLEAR R3
	LEA R1 FLAGD				; LOADS VALUE OF FLAGD TO R1
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2
	ADD R3 R2 #-1				; VALUE OF R2-1 TO R3
	BRz DECRYPT_STRING 			; BRANCH TO DECRYPT_STRING IF ZERO
	LEA R1 FLAGE
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2
	ADD R3 R2 #-1 				; R3 = R2 + (-1)
	BRz ENCRYPT_STRING 			; BRANCH TO ENCRYPT_STRING IF ZERO

E_LOWERCASE
	ADD R4 R4 R1				; SHIFT CHAR BY AMOUNT GIVEN BY SHIFTER
	LD R0 NEGATIVE_122
	ADD R5 R4 R0				; IF LETTER IS OVER 'z' (122) REMAINDER OF SHIFT GOES AFTER 'A'
	BRn ESKIP				; IF 0 GO TO ESKIP
	LD R0 NEGATIVE_26
	ADD R4 R4 R0				; R4 = R4 + R0			
	BR ESKIP 				; BRANCH TO ESKIP

E_UPPERCASE
	ADD R4 R4 R1 				; SHIFT CHAR BY AMOUNT GIVEN BY SHIFTER
	LD R0 NEGATIVE_90
	ADD R5 R4 R0				; IF LETTER IS OVER 'Z' (90) REMAINDER OF SHIFT GOES AFTER'A'
	BRn ESKIP				; IF 0 GO TO ESKIP
	LD R0 NEGATIVE_26
	ADD R4 R4 R0				; R4 = R4 + R0
	BR ESKIP 				; BRANCH TO ESKIP

D_LOWERCASE
	ADD R4 R4 R1 				; SHIFT CHAR BY AMOUNT GIVEN BY SHIFTER
	LD R0 NEGATIVE_97
	ADD R5 R4 R0				; IF LETTER GOES BELOW 'a' (97) REMAINDER OF SHIFT GOES BEFORE 'z'
	BRp DSKIP 				; BRANCH TO DSKIP IS POSITIVE
	ADD R4 R4 R0				; TAKE REMAINDER OF 'a' (97) MINUES R4 VALUE
	LD R0 NEGATIVE_123
	NOT R0 R0 				; INVERT R0
	ADD R0 R0 #1				; SHIFT R0 BY 1
	ADD R4 R4 R0				; SUBTRACT REMAINDER FROM 'z' (122) - RESULT IN R4
	BR DSKIP 				; BRANCH TO DSKIP

D_UPPERCASE
	ADD R4 R4 R1				; SHIFT CHAR BY AMOUNT GIVEN BY SHIFTER
	LD R0 NEGATIVE_65
	ADD R5 R4 R0				; IF LETTER GOES BELOW 'A' (65) REMAINDER OF SHIFT GOES BEFORE 'Z'
	BRp DSKIP 				; BRANCH TO DSKIP IF POSITIVE
	ADD R4 R4 R0 				; TAKE REMAINDER OF 'A' (65) MINUS R4 VALUE
	LD R0 NEGATIVE_91
	NOT R0 R0 				; INVERT R0
	ADD R0 R0 #1				; SHIFT R0 BY 1
	ADD R4 R4 R0				; SUBTRACT REMAINDER FROM 'Z' (90) NEW VALUE IN R4
	BR DSKIP 				; BRANCH TO DSKIP

ENCRYPT_STRING
	LEA R0 TOTAL_INTEGER
	LDR R1 R0 #0				; R1 HOLDS THE SHIFTER
	LEA R0 STRINGSTR1			; LOAD FIRST ADDRESS OF THE STRING
	ADD R0 R0 R3				; SHIFT ADDRESS BY COUNTER
	LDR R4 R0 #0				; R4 HOLDS THE INPUTTED CHAR
	LD R0 NEGATIVE_64
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRnz ESKIP				; BRANCH IF NEGATIVE OR ZERO TO EKSIP
	LD R0 NEGATIVE_91
	ADD R5 R4 R0 				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_92
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_93
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_94
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_95
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_96
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz ESKIP				; BRANCH IF ZERO TO EKSIP
	LD R0 NEGATIVE_123
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRzp ESKIP				; BRANCH IF ZERO OR POSTIVE TO EKSIP
	LD R0 NEGATIVE_90
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRnz E_UPPERCASE			; BRANCH IF NEGATIVE OR ZERO TO E_UPPERCASE
	BR E_LOWERCASE				; BRANCH TO E_LOWERCASE

DECRYPT_STRING
	LEA R0 TOTAL_INTEGER
	LDR R1 R0 #0				; R1 HOLDS THE SHIFTER
	NOT R1 R1 				; INVERT R1
	ADD R1 R1 #1 				; R1 = R1+1
	LEA R0 STRINGSTR1			; LOAD FIRST ADDRESS OF THE STRING
	ADD R0 R0 R3				; SHIFT ADDRESS BY COUNTER
	LDR R4 R0 #0				; R4 WILL HOLD INPUTTED CHAR
	LD R0 NEGATIVE_64
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRnz DSKIP				; BRANCH IF NEGATIVE OR ZERO TO DSKIP
	LD R0 NEGATIVE_91
	ADD R5 R4 R0 				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_92
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_93
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_94
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_95
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_96
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRz DSKIP				; BRANCH IF ZERO TO DKSIP
	LD R0 NEGATIVE_123
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRzp DSKIP				; BRANCH IF ZERO OR POSTIVE TO DSKIP
	LD R0 NEGATIVE_90
	ADD R5 R4 R0				; ADD INPUTTED CHAR WITH R0 - INPUT RESULT TO R5
	BRnz D_UPPERCASE			; BRANCH IF NEGATIVE OR ZERO TO D_UPPERCASE
	BR D_LOWERCASE				; BRANCH TO D_LOWERCASE
	
DECRYPT_STRING_PRINT
	LEA R0 DECRYPT_MSG			; "<DECRYPTION>"
	PUTS
	BR PRINT_STRING1 			; BRANCH TO PRINT_STRING1

ENCRYPT_STRING_PRINT
	LEA R0 ENCRYPT_MSG			; "<ENCRYPTION>"
	PUTS
	BR PRINT_STRING1 			; BRANCH TO PRINT_STRING1

DECRYPT_STRING_PRINT2
	LEA R0 DECRYPT_MSG			; "<DECRYPTION>"
	PUTS
	BR PRINT_STRING2_LOOP 			; BRANCH TO PRINT_STRING2_LOOP

ENCRYPT_STRING_PRINT2
	LEA R0 ENCRYPT_MSG			; "<ENCRYPTION>"
	PUTS
	BR PRINT_STRING2_LOOP 			; BRANCH TO PRINT_STRING2_LOOP

DECRYPT_MSG .STRINGZ "<Decrypted>: "
ENCRYPT_MSG .STRINGZ "<Encrypted>: "

DONE
	LD R0 NEWLINE1
	OUT
	AND R3 R3 #0				; CLEAR R3
	AND R5 R5 #0				; CLEAR R5
	LEA R1 FLAGD				; IF DECRYPT IS FLAG, PRINT <DECRYPTION>
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R1
	ADD R3 R2 #-1 				; R3 = R2 + (-1)
	BRz ENCRYPT_STRING_PRINT  		; IF ZERO, BRANCH TO ENCRYPT_STRING_PRINT
	LEA R1 FLAGE				; IF ENCRYPT IS FLAG, PRINT <ENCRYPTION>
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2
	ADD R3 R2 #-1 				; R3 = R2 + (-1)
	BRz DECRYPT_STRING_PRINT  		; IF ZERO, BRANCH TO DECRYPT_STRING_PRINT
	BR PRINT_STRING1			; BRANCH TO PRINT_STRING1

PRINT_STRING2
	LD R0 NEWLINE1
	OUT 
	AND R3 R3 #0				; CLEAR R3
	AND R5 R5 #0				; CLEAR R5
	LEA R1 FLAGD				; IF DECRYPT IS FLAG, PRINT <DECRYPTION>
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R1
	ADD R3 R2 #-1 				; R3 = R2 +(-1)
	BRz DECRYPT_STRING_PRINT2 		; BRANCH TO DECRYPT_STRING_PRINT2 IF ZERO
	LEA R1 FLAGE				; IF ENCRYPT IS FLAG, PRINT <ENCRYPTION>
	LDR R2 R1 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R1
	ADD R3 R2 #-1 				; R3 = R2 + (-1)
	BRz ENCRYPT_STRING_PRINT2 		; BRANCH TO ENCRYPT_STRING_PRINT2 IF ZERO
	BR PRINT_STRING2_LOOP 			; BRANCH TO PRINT_STRING2_LOOP

DSKIP
	LEA R0 STRINGSTR2			; LOAD FIRST ADDRESS OF SECOND STRING
	ADD R0 R0 R3				; SHIFT ADDRESS BY COUNTER
	STR R4 R0 #0				; STORE NEW VALUE INTO CORRESPONDING ADDRESS OF SECOND STRING
	ADD R3 R3 #1				; SHIFT ADDRESS BY 1
	LEA R0 COUNTER				; LOAD VALUE OF PREVIOUS COUNTER
	LDR R2 R0 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R0
	ADD R5 R3 R2 				; SUBTRACT PREVIOUS AND CURRENT COUNTER, IF ZERO FINISH
	BRz DONE 				; IF ZERO BRANCH TO DONE
	BR DECRYPT_STRING			; BRANCH TO DECRYPT_STRING

ESKIP
	LEA R0 STRINGSTR2			; LOAD FIRST ADDRESS OF SECOND STRING
	ADD R0 R0 R3				; SHIFT ADDRESS BY COUNTER
	STR R4 R0 #0				; STORE NEW VALUE INTO CORRESPONDING ADDRESS OF SECOND STRING
	ADD R3 R3 #1				; SHIFT ADDRESS BY 1
	LEA R0 COUNTER				; LOAD VALUE OF PREVIOUS COUNTER
	LDR R2 R0 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R0
	ADD R5 R3 R2				; SUBTRACT PREVIOUS AND CURRENT COUNTER, IF ZERO FINISH
	BRz DONE
	BR ENCRYPT_STRING

NEWLINE1 .FILL #10

PRINT_STRING1
	LEA R1 STRINGSTR1			; LOAD FIRST ADDRESS OF SECOND STRING
	ADD R1 R1 R3				; SHIFT ADDRESS WITH CURRENT VALUE IN COUNTER
	LDR R0 R1 #0				; LOAD VALUE OF CORRESPONDING ADDRESS
	ADD R3 R3 #1				; ADD ONE TO COUNTER
	OUT					; DISPLAY NUMBER OF ADDRESS
	LEA R0 COUNTER				; LOAD VALUE OF PREVIOUS COUNTER
	LDR R2 R0 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R0
	ADD R5 R3 R2				; SUBTRACT PREVIOUS AND CURRENT COUNTER, IF ZERO FINISH
	BRz PRINT_STRING2
	BR PRINT_STRING1

PRINT_STRING2_LOOP
	LEA R1 STRINGSTR2			; LOAD FIRST ADDRESS OF SECOND STRING
	ADD R1 R1 R3				; R1 = R1 + R3
	LDR R0 R1 #0				; LOAD VALUE OF CORRESPONDING ADDRESS
	ADD R3 R3 #1				; SHIFT ADDRESS BY 1
	OUT
	LEA R0 COUNTER				; LOAD ADDRESS OF PREVIOUS COUNTER
	LDR R2 R0 #0 				; ADD SIGN-EXTENDED 6 BIT OFFSET TO R2 FROM R0
	ADD R5 R3 R2				; SUBTRACT PREVIOUS AND CURRENT COUNTER, IF ZERO FINISH
	BRz FINISHED
	BR PRINT_STRING2_LOOP

NEGATIVE_97 .FILL #-97
NEGATIVE_65 .FILL #-65
NEGATIVE_123 .FILL #-123
NEGATIVE_122 .FILL #-122
NEGATIVE_90 .FILL #-90
NEGATIVE_26 .FILL #-26
NEGATIVE_91 .FILL #-91
NEGATIVE_64 .FILL #-64
NEGATIVE_92 .FILL #-92
NEGATIVE_93 .FILL #-93
NEGATIVE_94 .FILL #-94
NEGATIVE_95 .FILL #-95
NEGATIVE_96 .FILL #-96
STRINGSTR1 .BLKW 200
STRINGSTR2 .BLKW 200

.END